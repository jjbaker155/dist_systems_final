package examples.grpcClient;

import io.grpc.Channel;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;
import service.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * Client that requests `parrot` method from the `EchoServer`.
 */
public class Client {

  //These types are all autogenerated as part of gRPC
  //Recall: autogenerated stuff for protobuf

  private EchoGrpc.EchoBlockingStub echoBlockingStub;
  private JokeGrpc.JokeBlockingStub jokeBlockingStub;
  private RegistryGrpc.RegistryBlockingStub registryBlockingStub;
  private CalcGrpc.CalcBlockingStub calcBlockingStub;
  private StoryGrpc.StoryBlockingStub storyBlockingStub;
  private SettingsGrpc.SettingsBlockingStub settingsBlockingStub;
  private TipsGrpc.TipsBlockingStub tipsBlockingStub;
  private SortGrpc.SortBlockingStub sortBlockingStub;

  private static Scanner scan;
  private static String autoRun;
  private static boolean auto;
  private static final String DEFAULT_AUTORUN_PATH = "src/resources/autorun.txt";

  private static HashMap<String, ManagedChannel> serviceChannels;
  private static HashSet<String> availableServices;
  private static HashMap<String, String> serviceNames;

  /** Construct client for accessing server using the existing channel. */
  public Client(Channel regChannel) {
    serviceChannels = new HashMap<String, ManagedChannel>();
    registryBlockingStub = RegistryGrpc.newBlockingStub(regChannel); //regChannel is for the registry

    serviceChannels = new HashMap<String, ManagedChannel>();

  }

  public static ManagedChannel getServiceChannel(String target){
    if (!serviceChannels.containsKey(target)) {
      serviceChannels.put(target, ManagedChannelBuilder.forTarget(target).usePlaintext().build());
    }
    return (ManagedChannel) serviceChannels.get(target);
  }

  public static void closeAllServiceChannels(){
    Iterator<HashMap.Entry<String, ManagedChannel>> itr = serviceChannels.entrySet().iterator();
    while(itr.hasNext()){
      Map.Entry<String,ManagedChannel> pair = itr.next();
      pair.getValue().shutdownNow();
    }
  }

  public void updateServiceAvailability() throws ServiceNotAvailableException {
    GetServicesReq request = GetServicesReq.newBuilder().build();
    try {
      List<String> choiceList = registryBlockingStub.getServices(request).getServicesList();
      availableServices = new HashSet<String>();
      Iterator<String> itr = choiceList.iterator();

      while (itr.hasNext()) {
        //availableServices.add(s.substring(s.indexOf('.') + 1, s.indexOf('/')).toUpperCase());
        availableServices.add(itr.next());
      }
    } catch (Exception e) {
      throw new ServiceNotAvailableException("Could not retrieve services " +
              "list.\nServer may be offline or no services available\n" +
              "If problem persists, please contact system admin");
    }
  }

  public boolean isServiceAvail(String service){
    Iterator<String> itr = availableServices.iterator();
    while(itr.hasNext()){
      if(itr.next().equalsIgnoreCase(service)){
        return true;
      }
    }
    return false;
  }

  public void echo() throws IOException, ServiceNotAvailableException {
    if(!isServiceAvail("services.Echo/parrot")){
      throw new ServiceNotAvailableException("Parrot/Echo service is not available");
    }
    String message = scan.nextLine();
    ManagedChannel c = getServiceChannel(findServiceTarget("services.Echo/parrot"));
    echoBlockingStub = EchoGrpc.newBlockingStub(c);
    ClientRequest request = ClientRequest.newBuilder().setMessage(message).build();
    ServerResponse response;
    try {
      response = echoBlockingStub.parrot(request);
      System.out.println("Received from server: " + response.getMessage());
    } catch(StatusRuntimeException sre){
        throw new IOException("Server offline or parrot service unavailable");
    } catch (Exception e) {
        System.err.println("RPC failed: " + e.getMessage());
    } finally{
        System.out.println("Returning to main menu");
    }
  }

  public void askForJokes(int num) throws StatusRuntimeException {
    JokeReq request = JokeReq.newBuilder().setNumber(num).build();
    JokeRes response;

    try {
      response = jokeBlockingStub.getJoke(request);
      System.out.println("Your jokes: ");
      for (String joke : response.getJokeList()) {
        System.out.println("--- " + joke);
      }
    } catch(StatusRuntimeException sre){
        throw sre;
    }
  }

  public void setJoke(String joke) throws StatusRuntimeException {
    JokeSetReq request = JokeSetReq.newBuilder().setJoke(joke).build();
    JokeSetRes response;
    try {
      response = jokeBlockingStub.setJoke(request);
      System.out.println(response.getOk());
    } catch(StatusRuntimeException sre){
        throw sre;
    }
  }

  public void jokes() throws IOException, ServiceNotAvailableException {
    try {
      if(!isServiceAvail("services.Joke/setJoke")){
        throw new ServiceNotAvailableException("Jokes service is not available");
      }
      ManagedChannel c = getServiceChannel(findServiceTarget("services.Joke/setJoke"));
      jokeBlockingStub = JokeGrpc.newBlockingStub(c);
      System.out.println();
      System.out.println("Jokes Menu");
      System.out.println("1. Get Jokes");
      System.out.println("2. Add Jokes");
      System.out.println("0. Return to Main Menu");
      System.out.println(">");

      if (!scan.hasNextInt()) {
        scan.nextLine(); //dump the line
        throw new UserInputException("Entry must be an integer");
      }
      int choice = scan.nextInt();
      displayAutoInput(Integer.valueOf(Integer.valueOf(choice)));
      scan.nextLine(); //get rid of that pesky '/n'
      switch (choice) {
        case 1:
          System.out.println("How many jokes would you like?>");
          int num = scan.nextInt();
          displayAutoInput(Integer.valueOf(num));
          scan.nextLine();
          askForJokes(num);
          break;
        case 2:
          System.out.println("Please enter joke to add>");
          String newJoke = scan.nextLine();
          displayAutoInput(newJoke);
          setJoke(newJoke);
          break;
        case 0:
          throw new UserExitException();
        default:
          break;
      }
      } catch(UserInputException e){
          System.out.println(e.getMessage());
          switchToManual();
      } catch(UserExitException ee){
          //do nothing and just allow control to return to main()
      } catch(StatusRuntimeException sre){
          throw new IOException("Server offline or Jokes service unavailable");
      } catch (ServiceNotAvailableException sna) {
          System.out.println("The Jokes service is currently unavailable");
          throw sna;
    } finally{
        //System.in.readAllBytes();
        System.out.println("Returning to Main Menu");
      }
    }

  public void useCalc() throws IOException {
    try{
      if(!isServiceAvail("services.Calc/add")){
        throw new ServiceNotAvailableException("Calculator service is not available");
      }
      ManagedChannel c = getServiceChannel(findServiceTarget("services.Calc/add"));
      calcBlockingStub = CalcGrpc.newBlockingStub(c);
      System.out.println();
      System.out.println("Calculator Menu");
      System.out.println("Please select a function:");
      System.out.println("1. Addition");
      System.out.println("2. Subtraction");
      System.out.println("3. Multiplication");
      System.out.println("4. Division");
      System.out.println("0. Return to Main Menu");
      System.out.println(">");
      if(!scan.hasNextInt()){
        scan.nextLine(); //dump the line
        throw new UserInputException("Entry must be an integer");
      }
      int choice = scan.nextInt();
      displayAutoInput(Integer.valueOf(Integer.valueOf(choice)));
      scan.nextLine(); //get rid of that pesky '/n'
      if(choice == 0){
        throw new UserExitException("Returning to Main Menu");
      }
      if(choice < 0 || choice > 4){
        throw new UserInputException("Invalid Calculator Function Selected");
      }
      System.out.println("Please enter the operands for this function" +
              "\nThey should be seperated by spaces");
      String inString = scan.nextLine();
      String[] operandsIn = inString.split(" ");
      displayAutoInput(inString);
      ArrayList<Double> operands= new <Double>ArrayList();
      for(int i = 0; i < operandsIn.length; i++){
        operands.add(Double.parseDouble(operandsIn[i]));
      }
      CalcResponse response;
      CalcRequest.Builder builder = CalcRequest.newBuilder();
      builder.addAllNum(operands);
      CalcRequest req = builder.build();
      switch(choice){
        case 1:
          response = calcBlockingStub.add(req);
          break;
        case 2:
          response = calcBlockingStub.subtract(req);
          break;
        case 3:
          response = calcBlockingStub.multiply(req);
          break;
        case 4:
          response = calcBlockingStub.divide(req);
          break;
        default:
          throw new UserInputException("Invalid Calculator Function Selected");
      }

      if(!response.getIsSuccess()){
        System.out.println("Error: " + response.getError());
      } else{
        System.out.println("Solution: " + response.getSolution());
      }
    } catch(UserInputException e){
        System.out.println(e.getMessage());
        switchToManual();
    } catch(UserExitException ee){
        //do nothing and just allow control to return to main()
    } catch(NumberFormatException ne){
        System.out.println("This operation requires a list of 2 or more " +
              "numbers seperated by spaces");
        switchToManual();
    } catch(StatusRuntimeException sre){
        throw new IOException("Server offline or calculator service unavailable");
    } catch (ServiceNotAvailableException e) {
        System.out.println("The Calculator service is currently unavailable");
    } finally{
        //System.in.readAllBytes();
        System.out.println("Returning to Main Menu");
    }
  }

  public void story() throws IOException {
    try{
      if(!isServiceAvail("services.Story/read")){
        throw new ServiceNotAvailableException("Story service is not available");
      }
      ManagedChannel c = getServiceChannel(findServiceTarget("services.Story/read"));
      storyBlockingStub = StoryGrpc.newBlockingStub(c);
      System.out.println();
      System.out.println("Story Menu");
      System.out.println("Please select a service:");
      System.out.println("1. View Story So Far");
      System.out.println("2. Add to Story");
      System.out.println("0. Return to Main Menu");
      System.out.println(">");
      if(!scan.hasNextInt()){
        throw new UserInputException("Entry must be an integer");
      }
      int choice = scan.nextInt();
      displayAutoInput(Integer.valueOf(Integer.valueOf(choice)));
      scan.nextLine(); //get rid of that pesky '/n'
      switch(choice){
        case 1:
          Empty readReq = Empty.newBuilder().build();
          ReadResponse readResponse = storyBlockingStub.read(readReq);
          if(!readResponse.getIsSuccess()){
            System.out.println(readResponse.getError());
          } else{
            System.out.println("######The story so far######");
            System.out.println(readResponse.getSentence());
          }
          break;
        case 2:
          System.out.println("Enter a line to add>");
          String sentence = scan.nextLine();
          displayAutoInput(sentence);
          WriteRequest.Builder writeBuilder = WriteRequest.newBuilder();
          writeBuilder.setNewSentence(sentence);
          WriteRequest writeRequest = writeBuilder.build();
          WriteResponse writeResponse = storyBlockingStub.write(writeRequest);
          if(!writeResponse.getIsSuccess()){
            System.out.println(writeResponse.getError());
          }else{
            System.out.println("Your sentence added successfully\n");
            System.out.println("######The story so far######");
            System.out.println(writeResponse.getStory());
          }
          break;
        case 0:
          throw new UserExitException("Returning to Main Menu");
        default:
          throw new UserInputException("Invalid Option Selected");
      }
      //String sentence = input.nextLine();
    } catch(StatusRuntimeException sre){
        throw new IOException("Server offline or story service unavailable");
    } catch(UserInputException e){
        System.out.println(e.getMessage());
    } catch(UserExitException ee){
        //do nothing - let control go back to main()
    } catch (ServiceNotAvailableException e) {
        System.out.println("The Story service is currently unavailable");
    } finally{
      System.out.println("Returning to Main Menu");
    }
  }

  public void tips() throws IOException {
    try{
      if(!isServiceAvail("services.Tips/read")){
        throw new ServiceNotAvailableException("Tips service is not available");
      }
      ManagedChannel c = getServiceChannel(findServiceTarget("services.Tips/read"));
      tipsBlockingStub = TipsGrpc.newBlockingStub(c);
      System.out.println();
      System.out.println("Tips Menu");
      System.out.println("Please select a service:");
      System.out.println("1. View Tips");
      System.out.println("2. Add Tip");
      System.out.println("0. Return to Main Menu");
      System.out.println(">");
      if(!scan.hasNextInt()){
        throw new UserInputException("Entry must be an integer");
      }
      int choice = scan.nextInt();
      displayAutoInput(Integer.valueOf(Integer.valueOf(choice)));
      scan.nextLine(); //get rid of that pesky '/n'
      switch(choice){
        case 1:
          printTips();
          break;
        case 2:
          System.out.println("Enter a tip to add>");
          String sentence = scan.nextLine();
          displayAutoInput(sentence);
          System.out.println("Enter a user name>");
          String user = scan.nextLine();
          displayAutoInput(user);
          Tip.Builder tipBuilder = Tip.newBuilder();
          tipBuilder.setTip(sentence);
          tipBuilder.setName(user);
          Tip tip = tipBuilder.build();
          TipsWriteRequest.Builder writeBuilder = TipsWriteRequest.newBuilder();
          writeBuilder.setTip(tip);
          TipsWriteRequest writeRequest = writeBuilder.build();
          TipsWriteResponse writeResponse = tipsBlockingStub.write(writeRequest);
          if(!writeResponse.getIsSuccess()){
            System.out.println(writeResponse.getError());
          }else{
            System.out.println("Your tip added successfully\n");
            printTips();
          }
          break;
        case 0:
          throw new UserExitException("Returning to Main Menu");
        default:
          throw new UserInputException("Invalid Option Selected");
      }
      //String sentence = input.nextLine();
    } catch(StatusRuntimeException sre){
      throw new IOException("Server offline or story service unavailable");
    } catch(UserInputException e){
      System.out.println(e.getMessage());
    } catch(UserExitException ee){
      //do nothing - let control go back to main()
    } catch (ServiceNotAvailableException e) {
        System.out.println("The Tips service is currently unavailable");
    } finally{
      System.out.println("Returning to Main Menu");
    }
  }

  private void printTips(){
    Empty readReq = Empty.newBuilder().build();
    TipsReadResponse tipsReadResponse = tipsBlockingStub.read(readReq);
    if(!tipsReadResponse.getIsSuccess()){
      System.out.println(tipsReadResponse.getError());
    } else{
      System.out.println("######The Tips######");
      List<Tip> tips = tipsReadResponse.getTipsList();
      Iterator<Tip> itr = tips.iterator();
      while(itr.hasNext()){
        Tip tip = itr.next();
        System.out.println("From User: " + tip.getName() + " Tip: " + tip.getTip());
      }
    }
  }

  public void sort() throws IOException {
    try{
      if(!isServiceAvail("services.Sort/sort")){
        throw new ServiceNotAvailableException("Sort service is not available");
      }
      ManagedChannel c = getServiceChannel(findServiceTarget("services.Sort/sort"));
      sortBlockingStub = SortGrpc.newBlockingStub(c);
      System.out.println();
      System.out.println("Sort Menu");
      System.out.println("Please choose and algorithm:");
      System.out.println("1. Merge");
      System.out.println("2. Quick");
      System.out.println("3. System Native");
      System.out.println("0. Return to Main Menu");
      System.out.println(">");
      if(!scan.hasNextInt()){
        throw new UserInputException("Entry must be an integer");
      }
      int choice = scan.nextInt();
      displayAutoInput(Integer.valueOf(Integer.valueOf(choice)));
      scan.nextLine(); //get rid of that pesky '/n'

      System.out.println("Please enter an array of ints to sort (seperated by spaces)\n>");
      String inString = scan.nextLine();
      String[] operandsIn = inString.split(" ");
      displayAutoInput(inString);
      ArrayList<Integer> operands= new <Integer>ArrayList();
      for(int i = 0; i < operandsIn.length; i++){
        operands.add(Integer.parseInt(operandsIn[i]));
      }

      SortResponse response;
      SortRequest.Builder builder = SortRequest.newBuilder();
      builder.addAllData(operands);

      switch(choice){
        case 1:
          builder.setAlgo(Algo.valueOf("MERGE"));
          break;
        case 2:
          builder.setAlgo(Algo.valueOf("QUICK"));
          break;
        case 3:
          builder.setAlgo(Algo.valueOf("INTERN"));
        case 0:
          throw new UserExitException("Returning to Main Menu");
        default:
          throw new UserInputException("Invalid Option Selected");
      }
      SortRequest req = builder.build();
      response = sortBlockingStub.sort(req);
      if(!response.getIsSuccess()){
        System.out.println(response.getError());
      } else{
        System.out.println("Sorted Array:");
        List<Integer> list = response.getDataList();
        Iterator<Integer> itr = list.iterator();
        while(itr.hasNext()){
          System.out.print(itr.next() + " ");
        }
      }
    } catch(NumberFormatException ne){
        System.out.println("This operation requires a list of 2 or more " +
              "integers seperated by spaces");
        switchToManual();
    } catch(StatusRuntimeException sre){
        throw new IOException("Server offline or story service unavailable");
    } catch(UserInputException e){
        System.out.println(e.getMessage());
    } catch(UserExitException ee){
        //do nothing - let control go back to main()
    } catch (ServiceNotAvailableException e) {
        System.out.println("The Sort service is currently unavailable");
    } finally{
        System.out.println("Returning to Main Menu");
    }
  }

  public void printAllServices(boolean verbose) throws ServiceNotAvailableException {
    updateServiceAvailability();
    Iterator<String> itr = availableServices.iterator();
    while(itr.hasNext()){
      String s = itr.next();
      if(verbose){
        System.out.println(s);
      } else{
        System.out.println(s.substring(s.indexOf('.') + 1, s.indexOf('/')).toUpperCase());
      }
    }
  }

  public void getAllServices() {
    GetServicesReq request = GetServicesReq.newBuilder().build();
    ServicesListRes response;
    try {
      response = registryBlockingStub.getServices(request);
      //System.out.println(response.toString());
      //System.out.println(response.getServices(0).toString());
      //ProtocolStringListList<Service> list = response.getServicesList();
    } catch (Exception e) {
      //throw new ServiceNotAvailableException("Could not retrieve services " +
      //        "list.\n");
    }
  }

  public String findServiceTarget(String serviceName) throws ServiceNotAvailableException {
    FindServerReq request = FindServerReq.newBuilder().setServiceName(serviceName).build();
    SingleServerRes response;
    String result = null;
    try{
      response = registryBlockingStub.findServer(request);
      //response.getConnection().getUri();
      //System.out.println(response.toString());
      if(!response.getIsSuccess()){
        throw new ServiceNotAvailableException("The " + serviceName + " service is not currently available");
      } else{
        result = (response.getConnection().getUri() + ":" + response.getConnection().getPort());
      }
    }catch (ServiceNotAvailableException sna){
        throw sna;
    } catch (Exception e) {
        throw new ServiceNotAvailableException("The requested service is not currently available, or the server is offline");
    }
    return result;
  }

  public void switchToManual(){
    if(auto){
      auto = false;
      System.out.println("-----Switching to manual mode-----");
      scan.close();
      scan = new Scanner(System.in);
    }
  }

  public static void displayAutoInput(Object o){
    if(auto){
      System.out.println("---Auto input: " + o + "---\n");
    }
  }

  public void processList() throws IOException {
    try{
      if(!isServiceAvail("services.Settings/getProcessList")){
        throw new ServiceNotAvailableException("Process List service is not available");
      }
      ManagedChannel c = getServiceChannel(findServiceTarget("services.Settings/getProcessList"));
      settingsBlockingStub = SettingsGrpc.newBlockingStub(c);
      ProcessListReq req = ProcessListReq.newBuilder().build();
      ProcessListRes resp = settingsBlockingStub.getProcessList(req);
      if(!resp.getIsSuccessful()){
        System.out.println("Error retrieving process list");
      } else{
        List<String> result = resp.getProcessListList();
        Iterator<String> itr = result.iterator();
        System.out.println("\n###Processess###");
        while(itr.hasNext()){
          System.out.println(itr.next());
        }
      }
    } catch(StatusRuntimeException sre){
        throw new IOException("Server offline or Process List service unavailable");
    } catch (ServiceNotAvailableException e) {
        //System.out.println(e.getMessage());
        System.out.println("Process List service is unavailable");
    } finally{
      System.out.println("Returning to Main Menu");
    }
  }

  public void networkInfo() throws IOException {
    try{
      if(!isServiceAvail("services.Settings/getNetworkInfo")){
        throw new ServiceNotAvailableException("Network Info service is not available");
      }
      ManagedChannel c = getServiceChannel(findServiceTarget("services.Settings/getNetworkInfo"));
      settingsBlockingStub = SettingsGrpc.newBlockingStub(c);
      NetworkInfoReq req = NetworkInfoReq.newBuilder().build();
      NetworkInfoRes resp = settingsBlockingStub.getNetworkInfo(req);
      if(!resp.getIsSuccessful()){
        System.out.println("Error retrieving network info");
      } else{
        List<String> result = resp.getNetworkInfoList();
        Iterator<String> itr = result.iterator();
        System.out.println("\n###Network Info List###");
        while(itr.hasNext()){
          System.out.println(itr.next());
        }
      }
    } catch(StatusRuntimeException sre){
        throw new IOException("Server offline or Network Info service unavailable");
    } catch (ServiceNotAvailableException e) {
        System.out.println("Network Info service is unavailable");
        //System.out.println(e.getMessage());
    }finally{
      System.out.println("Returning to Main Menu");
    }
  }


  public static void main(String[] args) throws Exception {
    if (args.length != 6) {
      System.out
          .println("Expected arguments: <host(String)> <port(int)> <regHost(string)>" +
                  " <regPort(int)> <message(String)> <automode(int)>");
      System.exit(1);
    }

    auto = false;
    int port = 9099;
    int regPort = 9003;
    String host = args[0];
    String regHost = args[2];
    String message = args[4];
    try {
      port = Integer.parseInt(args[1]);
      regPort = Integer.parseInt(args[3]);
      if(Integer.parseInt(args[5]) == 1) {
        auto = true;
      }
    } catch (NumberFormatException nfe) {
      System.out.println("<port>, <regport> and <automode> be integers");
      System.out
              .println("Arguments format: <host(String)> <port(int)> <regHost(string)>" +
                      " <regPort(int)> <message(String)> <automode(int)>");
      System.exit(2);
    }

    if(auto){
      try{
        File autoRunFile = new File(DEFAULT_AUTORUN_PATH);
        autoRun = Files.readString(autoRunFile.toPath(), StandardCharsets.US_ASCII);
        scan = new Scanner(autoRun);
      } catch(FileNotFoundException fe){
        System.out.println("Autorun file not found. Continuing in manual mode.");
        scan = new Scanner(System.in);
      } catch(IOException ioe){
        System.out.println("Autorun file is corrupt. Continuing in manual mode.");
        scan = new Scanner(System.in);
      } finally{
        if (autoRun.isEmpty()){
          System.out.println("Autorun file is empty. Continuing in manual mode.");
          scan = new Scanner(System.in);
        } else{
          System.out.println("---Auto Mode---");
        }
      }
    } else{
      scan = new Scanner(System.in);
    }

    // Create a communication channel to the server, known as a Channel. Channels
    // are thread-safe and reusable. It is common to create channels at the beginning
    // of your application and reuse them until the application shuts down.
    //this will NOT be hardcoded like this in the final version. The target will vary
    //depending on the service selected by the user
        // Channels are secure by default (via SSL/TLS). For the example we disable TLS
        // to avoid needing certificates.
        //channel.


    String regTarget = regHost + ":" + regPort;
    ManagedChannel regChannel = ManagedChannelBuilder.forTarget(regTarget).usePlaintext().build();
    try {

      Client client = new Client(regChannel);

      client.printAllServices(true);

      boolean quit = false;
      int menuChoice;
      // Reading data using readLine
      while (!quit) {
        client.updateServiceAvailability();
        System.out.println();
        System.out.println("Main Menu");
        System.out.println("The following services are available:");
        if (client.isServiceAvail("services.Echo/parrot")) {
          System.out.println("1. Parrot");
        }
        if (client.isServiceAvail("services.Joke/setJoke")) {
          System.out.println("2. Jokes");
        }
        if (client.isServiceAvail("services.Calc/add")) {
          System.out.println("3. Calculator");
        }
        if (client.isServiceAvail("services.Story/write")) {
          System.out.println("4. Story");
        }
        if (client.isServiceAvail("services.Settings/getProcessList")) {
          System.out.println("5. Display List of Server Processes");
          System.out.println("6. Display Server Network Info");
          System.out.println("7. Execute System Command");
        }
        if (client.isServiceAvail("services.Sort/sort")) {
          System.out.println("8. Sort");
        }
        if (client.isServiceAvail("services.Tips/read")) {
          System.out.println("9. Tips");
        }
        System.out.println("0. Quit");
        System.out.println("10. Refresh Available Services");
        System.out.println(">");
        try {
          menuChoice = scan.nextInt();
          displayAutoInput(Integer.valueOf(menuChoice));
          scan.nextLine();
          switch (menuChoice) {
            case 1:
              System.out.println("Please enter line to parrot>");
              client.echo();
              break;
            case 2:
              client.jokes();
              break;
            case 3:
              client.useCalc();
              break;
            case 4:
              client.story();
              break;
            case 5:
              client.processList();
              break;
            case 6:
              client.networkInfo();
              break;
            case 7:
              System.out.println("For security reasons, this feature has been disabled.");
              break;
            case 8:
              client.sort();
              break;
            case 9:
              client.tips();
              break;
            case 0:
              quit = true;
              System.out.println("See you next time");
              break;
            case 10:
              throw new RefreshServices();
            default:
              System.out.println("Please select a valid option from the menu");
              break;
          }
        } catch (RefreshServices rs){
            System.out.println("Refreshing available services");
        } catch (ServiceNotAvailableException sna) {
            System.out.println(sna.getMessage());
            client.switchToManual();
        } catch (InputMismatchException e) {
            System.out.println("Entry must be an integer");
            client.switchToManual();
            System.out.println("Please select a valid option from the menu");
            client.switchToManual();
        } catch (NoSuchElementException nse) {
            System.out.println("Scanner does not have other element...");
            client.switchToManual();
            System.out.println("Please select a valid option from the menu");
        } catch (IOException ioe) {
            System.out.println(ioe.getMessage());
            System.out.println("Check server status.");
            System.out.println("Check host and port number.");
            client.switchToManual();
        }
      }
    } catch (ServiceNotAvailableException sna){
        System.out.println("\nServer offline or no services available");
        System.out.println("If problem persists, please contact system admin");
    } finally {
        // ManagedChannels use resources like threads and TCP connections. To prevent
        // leaking these
        // resources the channel should be shut down when it will no longer be used. If
        // it may be used again leave it running.
        scan.close();
        Client.closeAllServiceChannels();
        regChannel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
    }
  }
}