package examples.grpcClient;

import io.grpc.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.TimeUnit;
import service.*;
import java.io.IOException;

/**
 * Client that requests `parrot` method from the `EchoServer`.
 */
public class EchoClient {

  //These types are all autogenerated as part of gRPC
  //Recall: autogenerated stuff for protobuf
  private final EchoGrpc.EchoBlockingStub blockingStub;
  private final JokeGrpc.JokeBlockingStub blockingStub2;
  private final RegistryGrpc.RegistryBlockingStub blockingStub3;
  private final CalcGrpc.CalcBlockingStub blockingStub4;
  private final StoryGrpc.StoryBlockingStub blockingStub5;
  private final SettingsGrpc.SettingsBlockingStub settingsBlockingStub;

  private static Scanner scan;
  private static String autoRun;
  private static boolean auto;
  private static final String DEFAULT_AUTORUN_PATH = "src/resources/autorun.txt";

  /** Construct client for accessing server using the existing channel. */
  public EchoClient(Channel channel, Channel regChannel) { 
    // 'channel' here is a Channel, not a ManagedChannel, so it is not this code's
    // responsibility to shut it down.
    //For task 1 channel will be needed. For task 2, regChannel will be needed

    // Passing Channels to code makes code easier to test and makes it easier to
    // reuse Channels.
    blockingStub = EchoGrpc.newBlockingStub(channel);
    blockingStub2 = JokeGrpc.newBlockingStub(channel);
    blockingStub4 = CalcGrpc.newBlockingStub(channel); //channel is for services
    blockingStub5 = StoryGrpc.newBlockingStub(channel);
    settingsBlockingStub = SettingsGrpc.newBlockingStub(channel);
    blockingStub3 = RegistryGrpc.newBlockingStub(regChannel); //regChannel is for the registry
  }

  public void askServerToParrot(String message) throws IOException {
    ClientRequest request = ClientRequest.newBuilder().setMessage(message).build();
    ServerResponse response;
    try {
      response = blockingStub.parrot(request);
      System.out.println("Received from server: " + response.getMessage());
    } catch(StatusRuntimeException sre){
      throw new IOException("Server offline or joke service unavailable");
    } catch (Exception e) {
      System.err.println("RPC failed: " + e.getMessage());
    } finally{
      System.out.println("Returning to main menu");
    }
  }

  public void askForJokes(int num) throws StatusRuntimeException {
    JokeReq request = JokeReq.newBuilder().setNumber(num).build();
    JokeRes response;

    try {
      response = blockingStub2.getJoke(request);
      System.out.println("Your jokes: ");
      for (String joke : response.getJokeList()) {
        System.out.println("--- " + joke);
      }
    } catch(StatusRuntimeException sre){
        throw sre;
    }
  }

  public void setJoke(String joke) throws StatusRuntimeException {
    JokeSetReq request = JokeSetReq.newBuilder().setJoke(joke).build();
    JokeSetRes response;
    try {
      response = blockingStub2.setJoke(request);
      System.out.println(response.getOk());
    } catch(StatusRuntimeException sre){
        throw sre;
    }
  }

  public void jokes() throws IOException {
    try {
      System.out.println();
      System.out.println("Jokes Menu");
      System.out.println("1. Get Jokes");
      System.out.println("2. Add Jokes");
      System.out.println("0. Return to Main Menu");
      System.out.println(">");

      if (!scan.hasNextInt()) {
        scan.nextLine(); //dump the line
        throw new UserInputException("Entry must be an integer");
      }
      int choice = scan.nextInt();
      displayAutoInput(Integer.valueOf(Integer.valueOf(choice)));
      scan.nextLine(); //get rid of that pesky '/n'
      switch (choice) {
        case 1:
          System.out.println("How many jokes would you like?>");
          int num = scan.nextInt();
          displayAutoInput(Integer.valueOf(num));
          scan.nextLine();
          askForJokes(num);
          break;
        case 2:
          System.out.println("How many jokes would you like?>");
          String newJoke = scan.nextLine();
          displayAutoInput(newJoke);
          setJoke(newJoke);
          break;
        case 0:
          throw new UserExitException();
        default:
          break;
      }
      } catch(UserInputException e){
        System.out.println(e.getMessage());
        switchToManual();
      } catch(UserExitException ee){
        //do nothing and just allow control to return to main()
      } catch(StatusRuntimeException sre){
        throw new IOException("Server offline or jokes service unavailable");
      } finally{
        //System.in.readAllBytes();
        System.out.println("Returning to Main Menu");
      }
    }

  public void useCalc() throws IOException {
    try{
      System.out.println();
      System.out.println("Calculator Menu");
      System.out.println("Please select a function:");
      System.out.println("1. Addition");
      System.out.println("2. Subtraction");
      System.out.println("3. Multiplication");
      System.out.println("4. Division");
      System.out.println("0. Return to Main Menu");
      System.out.println(">");
      if(!scan.hasNextInt()){
        scan.nextLine(); //dump the line
        throw new UserInputException("Entry must be an integer");
      }
      int choice = scan.nextInt();
      displayAutoInput(Integer.valueOf(Integer.valueOf(choice)));
      scan.nextLine(); //get rid of that pesky '/n'
      if(choice == 0){
        throw new UserExitException("Returning to Main Menu");
      }
      if(choice < 0 || choice > 4){
        throw new UserInputException("Invalid Calculator Function Selected");
      }
      System.out.println("Please enter the operands for this function" +
              "\nThey should be seperated by spaces");
      String inString = scan.nextLine();
      String[] operandsIn = inString.split(" ");
      displayAutoInput(inString);
      ArrayList<Double> operands= new <Double>ArrayList();
      for(int i = 0; i < operandsIn.length; i++){
        operands.add(Double.parseDouble(operandsIn[i]));
      }
      CalcResponse response;
      CalcRequest.Builder builder = CalcRequest.newBuilder();
      builder.addAllNum(operands);
      CalcRequest req = builder.build();
      switch(choice){
        case 1:
          response = blockingStub4.add(req);
          break;
        case 2:
          response = blockingStub4.subtract(req);
          break;
        case 3:
          response = blockingStub4.multiply(req);
          break;
        case 4:
          response = blockingStub4.divide(req);
          break;
        default:
          throw new UserInputException("Invalid Calculator Function Selected");
      }

      if(!response.getIsSuccess()){
        System.out.println("Error: " + response.getError());
      } else{
        System.out.println("Solution: " + response.getSolution());
      }
    } catch(UserInputException e){
        System.out.println(e.getMessage());
        switchToManual();
    } catch(UserExitException ee){
      //do nothing and just allow control to return to main()
    } catch(NumberFormatException ne){
      System.out.println("This operation requires a list of 2 or more " +
              "numbers seperated by spaces");
      switchToManual();
    } catch(StatusRuntimeException sre){
      throw new IOException("Server offline or calculator service unavailable");
    }finally{
      //System.in.readAllBytes();
      System.out.println("Returning to Main Menu");
    }
  }

  public void story() throws IOException {
    try{
      System.out.println();
      System.out.println("Story Menu");
      System.out.println("Please select a service:");
      System.out.println("1. View Story So Far");
      System.out.println("2. Add to Story");
      System.out.println("0. Return to Main Menu");
      System.out.println(">");
      if(!scan.hasNextInt()){
        throw new UserInputException("Entry must be an integer");
      }
      int choice = scan.nextInt();
      displayAutoInput(Integer.valueOf(Integer.valueOf(choice)));
      scan.nextLine(); //get rid of that pesky '/n'
      switch(choice){
        case 1:
          Empty readReq = Empty.newBuilder().build();
          ReadResponse readResponse = blockingStub5.read(readReq);
          if(!readResponse.getIsSuccess()){
            System.out.println(readResponse.getError());
          } else{
            System.out.println("######The story so far######");
            System.out.println(readResponse.getSentence());
          }
          break;
        case 2:
          System.out.println("Enter a line to add>");
          String sentence = scan.nextLine();
          displayAutoInput(sentence);
          WriteRequest.Builder writeBuilder = WriteRequest.newBuilder();
          writeBuilder.setNewSentence(sentence);
          WriteRequest writeRequest = writeBuilder.build();
          WriteResponse writeResponse = blockingStub5.write(writeRequest);
          if(!writeResponse.getIsSuccess()){
            System.out.println(writeResponse.getError());
          }else{
            System.out.println("Your sentence added successfully\n");
            System.out.println("######The story so far######");
            System.out.println(writeResponse.getStory());
          }
          break;
        case 0:
          throw new UserExitException("Returning to Main Menu");
        default:
          throw new UserInputException("Invalid Option Selected");
      }
      //String sentence = input.nextLine();
    } catch(StatusRuntimeException sre){
      throw new IOException("Server offline or story service unavailable");
    } catch(UserInputException e){
      System.out.println(e.getMessage());
    } catch(UserExitException ee){
      //do nothing - let control go back to main()
    } finally{
      System.out.println("Returning to Main Menu");
    }
  }

  //This will be used in task 3 - for now, just hard code choices in the client
  public void getServices() {
    GetServicesReq request = GetServicesReq.newBuilder().build();
    ServicesListRes response;
    try {
      response = blockingStub3.getServices(request);
      System.out.println(response.toString());
    } catch (Exception e) {
      System.err.println("RPC failed: " + e);
      return;
    }
  }

  public void findServer(String name) {
    FindServerReq request = FindServerReq.newBuilder().setServiceName(name).build();
    SingleServerRes response;
    try {
      response = blockingStub3.findServer(request);
      System.out.println(response.toString());
    } catch (Exception e) {
      System.err.println("RPC failed: " + e);
      return;
    }
  }

  public void findServers(String name) {
    FindServersReq request = FindServersReq.newBuilder().setServiceName(name).build();
    ServerListRes response;
    try {
      response = blockingStub3.findServers(request);
      System.out.println(response.toString());
    } catch (Exception e) {
      System.err.println("RPC failed: " + e);
      return;
    }
  }

  public void switchToManual(){
    if(auto){
      auto = false;
      System.out.println("-----Switching to manual mode-----");
      scan.close();
      scan = new Scanner(System.in);
    }
  }

  public static void displayAutoInput(Object o){
    if(auto){
      System.out.println("---Auto input: " + o + "---\n");
    }
  }

  public void processList() throws IOException {
    try{
      ProcessListReq req = ProcessListReq.newBuilder().build();
      ProcessListRes resp = settingsBlockingStub.getProcessList(req);
      if(!resp.getIsSuccessful()){
        System.out.println("Error retrieving process list");
      } else{
        List<String> result = resp.getProcessListList();
        Iterator<String> itr = result.iterator();
        System.out.println("\n###Processess###");
        while(itr.hasNext()){
          System.out.println(itr.next());
        }
      }
    } catch(StatusRuntimeException sre){
        throw new IOException("Server offline or Settings service unavailable");
    } finally{
      System.out.println("Returning to Main Menu");
    }
  }

  public void networkInfo() throws IOException {
    try{
      NetworkInfoReq req = NetworkInfoReq.newBuilder().build();
      NetworkInfoRes resp = settingsBlockingStub.getNetworkInfo(req);
      if(!resp.getIsSuccessful()){
        System.out.println("Error retrieving network info");
      } else{
        List<String> result = resp.getNetworkInfoList();
        Iterator<String> itr = result.iterator();
        System.out.println("\n###Network Info List###");
        while(itr.hasNext()){
          System.out.println(itr.next());
        }
      }
    } catch(StatusRuntimeException sre){
      throw new IOException("Server offline or Settings service unavailable");
    } finally{
      System.out.println("Returning to Main Menu");
    }
  }

  public static void main(String[] args) throws Exception {
    if (args.length != 6) {
      System.out
          .println("Expected arguments: <host(String)> <port(int)> <regHost(string)>" +
                  " <regPort(int)> <message(String)> <automode(int)>");
      System.exit(1);
    }

    auto = false;
    int port = 9099;
    int regPort = 9003;
    String host = args[0];
    String regHost = args[2];
    String message = args[4];
    try {
      port = Integer.parseInt(args[1]);
      regPort = Integer.parseInt(args[3]);
      if(Integer.parseInt(args[5]) == 1) {
        auto = true;
      }
    } catch (NumberFormatException nfe) {
      System.out.println("<port>, <regport> and <automode> be integers");
      System.out
              .println("Arguments format: <host(String)> <port(int)> <regHost(string)>" +
                      " <regPort(int)> <message(String)> <automode(int)>");
      System.exit(2);
    }

    if(auto){
      try{
        File autoRunFile = new File(DEFAULT_AUTORUN_PATH);
        autoRun = Files.readString(autoRunFile.toPath(), StandardCharsets.US_ASCII);
        scan = new Scanner(autoRun);
      } catch(FileNotFoundException fe){
        System.out.println("Autorun file not found. Continuing in manual mode.");
        scan = new Scanner(System.in);
      } catch(IOException ioe){
        System.out.println("Autorun file is corrupt. Continuing in manual mode.");
        scan = new Scanner(System.in);
      } finally{
        if (autoRun.isEmpty()){
          System.out.println("Autorun file is empty. Continuing in manual mode.");
          scan = new Scanner(System.in);
        } else{
          System.out.println("---Auto Mode---");
        }
      }
    } else{
      scan = new Scanner(System.in);
    }

    // Create a communication channel to the server, known as a Channel. Channels
    // are thread-safe and reusable. It is common to create channels at the beginning
    // of your application and reuse them until the application shuts down.
    //this will NOT be hardcoded like this in the final version. The target will vary
    //depending on the service selected by the user
    String target = host + ":" + port;
    ManagedChannel channel = ManagedChannelBuilder.forTarget(target)
        // Channels are secure by default (via SSL/TLS). For the example we disable TLS
        // to avoid needing certificates.
        .usePlaintext().build();



    String regTarget = regHost + ":" + regPort;
    ManagedChannel regChannel = ManagedChannelBuilder.forTarget(regTarget).usePlaintext().build();
    try {

      // ##############################################################################
      // ## Assume we know the port here from the service node it is basically set through Gradle
      // here.
      // In your version you should first contact the registry to check which services
      // are available and what the port etc is.

      /**
       * Your client should start off with
       * 1. contacting the Registry to check for the available services
       * 2. List the services in the terminal and the client can
       *    choose one (preferably through numbering)
       * 3. Based on what the client chooses
       *    the terminal should ask for input, eg. a new sentence, a sorting array or
       *    whatever the request needs
       * 4. The request should be sent to one of the
       *    available services (client should call the registry again and ask for a
       *    Server providing the chosen service) should send the request to this service and
       *    return the response in a good way to the client
       *
       * You should make sure your client does not crash in case the service node
       * crashes or went offline.
       */

      EchoClient client = new EchoClient(channel, regChannel);


      boolean quit = false;
      int menuChoice;
      while(!quit){
        System.out.println();
        System.out.println("Main Menu");
        System.out.println("Please select a service:");
        System.out.println("1. Parrot");
        System.out.println("2. Jokes");
        System.out.println("3. Calculator");
        System.out.println("4. Story");
        System.out.println("5. Display List of Server Processes");
        System.out.println("6. Display Server Network Info");
        System.out.println("0. quit");
        System.out.println(">");
        try{
          //checking channel connectivity DIRECT to a node - not the registry
          //ConnectivityState state = channel.getState(true);
          //if(state == ConnectivityState.SHUTDOWN || state == ConnectivityState.TRANSIENT_FAILURE){
          //  throw new IOException("Cannot reach server.");
          //}
          //System.out.println(state.toString());
          menuChoice = scan.nextInt();
          displayAutoInput(Integer.valueOf(menuChoice));
          scan.nextLine();
          switch(menuChoice){
            case 1:
              System.out.println("Please enter line to parrot>");
              String msg = scan.nextLine();
              client.askServerToParrot(msg);
              break;
            case 2:
              client.jokes();
              break;
            case 3:
              client.useCalc();
              break;
            case 4:
              client.story();
              break;
            case 5:
              client.processList();
              break;
            case 6:
              client.networkInfo();
              break;
            case 0:
              quit = true;
              System.out.println("See you next time");
              break;
            default:
              System.out.println("Please select a valid option from the menu");
              break;
          }
        } catch(InputMismatchException e) {
          System.out.println("Entry must be an integer");
          client.switchToManual();
          System.out.println("Please select a valid option from the menu");
          client.switchToManual();
        }catch (NoSuchElementException nse){
          System.out.println("Scanner does not have other element...");
          client.switchToManual();
          System.out.println("Please select a valid option from the menu");
        } catch (IOException ioe){
          System.out.println(ioe.getMessage());
          System.out.println("Check server status.");
          System.out.println("Check host and port number.");
          client.switchToManual();
        }
      }


    } finally {
      // ManagedChannels use resources like threads and TCP connections. To prevent
      // leaking these
      // resources the channel should be shut down when it will no longer be used. If
      // it may be used
      // again leave it running.
      scan.close();
      channel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
      regChannel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
    }
  }
}
